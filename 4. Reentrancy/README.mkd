# Reentrancy

Ethernaut'un başka bir seviyesine hoşgeldiniz. [Reentrancy](https://ethernaut.openzeppelin.com/level/0xe6BA07257a9321e755184FB2F995e0600E78c16D) seviyemiz oldukça önemli çünkü Reentrancy konsepti meşhur Ethereum DAO Hack'ine sebep olan bir zaafiyettir ki bu hack sonucunda Ethereum ağı Ethereum ve Ethereum Classic olmak üzere ayrıldı. Bazı metotlar çağrıldığında Reentrancy olayını önlemek için OpenZeppelin, ReentrancyGuard adlı bir modifier ve PullPayment adlı bir sözleşme geliştirmiş. Reentrancy zaafiyetini bu seviyede iyice kavrayalım ki OpenZeppelin'in geliştirdiği güvenlik kitlerini ne zaman kullanmamız gerektiğini öğrenelim. Hazırsanız başlayalım!

Seviyeninden bizden beklentisi sözleşmedeki bütün fonları ele geçirmemiz. Seviyeyi geçmemizde yardımcı olabilecek maddeler ise şöyle:

 1. Güvenilmeyen sözleşmeler beklemediğiniz bir yerde kod çalıştırabilir.
 2. Fallback metotları
 3. Throw/revert bubbling (Çok fazla sayıda bu metotların çağrılması)
 4. Bazen bir sözleşmeye saldırmanın en iyi yolu başka bir sözleşmedir.

Reentrance sözleşmesini inceleyecek olursak, bu basit bir cüzdan sözleşmesi. Donate metodunu çağırıp sözleşmeye Ether gönderen adreslerin bakiyeleri mapping veri yapısında tutuluyor. Adresler, bakiyeleri kadar Ether'i withdraw metoduyla çekebiliyorlar. Gelin isterseniz withdraw metodunu inceleyelim.

Withdraw metodundaki kodun çalışabilmesi için işlemi gönderen kişinin bakiyesinin çekilmek istenen tutardan (_amount parametresi) fazla veya eşit olması lazım; eğer olmazsa, if ifadesindeki koşul sağlanmaz ve kod çalışmaz. Koşul sağlandığı zaman withdraw metodunun ikinci satırındaki Ether transfer işlemi devreye giriyor. **Call{value: _amount}** ifadesi nasıl transfer işlemi oluyor diye sorabilirsiniz. **Msg.sender.call("")** ifadesi işlemi gönderen adresteki metotları çağırmakta işimize yarıyor(Metot isimlerini parantez içine yazıyoruz). Fakat bizim incelediğimiz call metodunda herhangi bir metot çağrılmamış ve işlemde Ether gönderilmiş, yani bir Fallback metotu! Fallback metotunu hatırlamak veya öğrenmek için ilk yazımı okuyabilirsiniz. Eğer işlem gönderen adres bir sözleşme değil de Externally Owned Account (Türkçe nasıl ifade edileceğini bilemedim ama MetaMask'taki Ethereum adresimiz diyebiliriz.) ise herhangi bir metot çağrılamaz, yani basit bir Ether transfer işlemi gerçekleştirilir. İşte burada gelin beyin fırtınası yapalım: kendi oluşturduğumuz sözleşmede yazdığımız Fallback metotunun içindeki kodun işlevi konusunda özgürüz: başka bir sözleşmedeki metotu çağırabiliriz, Ether göndeririz... Bu özgürlükten faydalanacağız çünkü msg.sender ya da işlemi gönderen adres bir sözleşme de olabilir. Fallback metotu çağrıldıktan sonra çekilen miktar adresin bakiyesinden düşülüyor. Her şey mükemmel ve sorunsuz gözüküyor değil mi? Maalesef öyle değil.

Yukarıdaki paragrafta kendi oluşturduğumuz sözleşmedeki Fallback metodunun barındırdığı kodun işlevi konusunda özgürüz demiştik. Reentrance sözleşmesinde de Fallback metotu çağrıldıktan sonra adresin bakiyesi azalıyor. Peki, şöyle bir şey denesek: Öyle bir sözleşme oluşturalım ki kendi adresine bakiye ekleyebilsin ve Fallback metodu da olsun. Burada önemli olan kısım ise şu: Fallback metodunda Reentrance sözleşmesindeki withdraw metodunu çağrırsak ne olur? Gelin örnek verelim:

 1. Sözleşme adresimizle Reentrance sözleşmesindeki (sözleşme bakiyesi 1.0 Ether) bakiyemizi 0.1 Ether yapmak istedik ve donate metodunu çağırdık, artık sözleşmesi adresimizle withdraw fonksiyonunu çağırabiliriz.
 2. Reentrance sözleşmesindeki withdraw metodunu çağırması için oluşturduğumuz metodu çağıralım (metodun ismi addDonate() olabilir); çekmek istediğimiz miktar 0.1 Ether. Fallback metodumuzda da addDonate() metodunu çağıralım.
 3. Reentrance sözleşmesindeki withdraw metodundaki if koşulu sağlanıyor ve hemen ardından sözleşmemizdeki fallback metotu çağrılıyor, sözleşme bakiyemize 0.1 Ether aktarılıyor ve Fallback metodumuzdaki addDonate() (0.1 Ether çekme işlemi) metodu çağrılıyor, başka bir deyişle Reentrance sözleşmesindeki withdraw metodu bir daha çağrılıyor. Daha önceden bakiyemiz kadar transfer yaptığımız için bakiyemizin sıfır olması lazım değil mi? Eğer öyleyse, if ifadesindeki koşulun sağlanamaması lazım. Fakat çekilen miktar bakiyemizden düşülmeden önce fallback metodu çağrıldığı için if koşulu sağlanıyor ve bir daha 0.1 Ether sözleşme adresimizde gönderiliyor.
 4. Böylece Reentrance sözleşmesindeki bütün Ether'leri çekene kadar 0.1 Ether çekiyoruz. 1 Ether'lik bakiyeyi de böylece sıfırlıyoruz.

Eğer çekilen miktar kadar bakiyeden düşme işlemini (withdraw metodundaki son kod satırı) call metodundan önce gerçekleştirseydik böyle bir sorun yaşanmazdı. Reentrance sözleşmesini hacklemek için yukarıda anlattığım sözleşme modelini Reenter.sol belgesinde bulabilirsiniz. Reenter sözleşmesini Remix IDE üzerinden Rinkeby ağına yayımlamanızı tavsiye ediyorum çünkü Reentrance sözleşmesini hacklemek için kendi sözleşmemizden bazı metotlar çağırmak zorundayız (Reenter.sol'da detaylı anlattım bu kısmı).
